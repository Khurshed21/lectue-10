# Axios

Axios - это популярная библиотека для выполнения HTTP-запросов в браузере и на сервере. Она предоставляет удобный интерфейс для работы с сетевыми запросами и обещаниями (promises).
___

# Пример использования

``` Javascript
const axios = require('axios');

axios.get('https://api.example.com/users')
  .then(response => {
    console.log(response.data);
  })
  .catch(error => {
    console.error('Ошибка при выполнении запроса:', error);
  });
```
___

# Цикл событий (Event Loop) в JavaScript

Цикл событий (Event Loop) - это механизм в JavaScript, который позволяет обрабатывать события и выполнять асинхронный код. Он позволяет JavaScript быть однопоточным и все еще обрабатывать несколько задач.
___

# Принцип работы

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSJ01NZRzjo5y2uUA6IpQQfaZelL3R5Dwjd_DnAoNwi-RHOeOtAWZojYcBy-OaEYp5KG2Y&usqp=CAU)
___

``` JavaScript
let acc = 1;
console.log("Call 1:", acc);

acc++;
console.log("Call 2:", acc);

setTimeout(() => {
  acc++;
  console.log("Call 3:", acc);
}, 0);

let anotherAcc = acc;
console.log("Call 4:", anotherAcc, acc);


/* console.log

Call 1: 1
Call 2: 2
Call 4: 2 2
Call 3: 3
```
___

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d0b/55a/66f/d0b55a66f050fbfe6668b7074a3bc539.png)

# Callstack

Среда выполнения JavaScript содержит очередь задач. Эта очередь — список задач, подлежащих обработке. Каждая задача ассоциируется с некоторой функцией, которая будет вызвана, чтобы обработать эту задачу.

Когда стек полностью освобождается, самая первая задача извлекается из очереди и обрабатывается. Обработка задачи состоит в вызове ассоциированной с ней функции с параметрами, записанными в этой задаче. Как обычно, вызов функции создаёт новый контекст выполнения и заносится в стек вызовов.
___

# Макрозадачи и Микрозадачи

Помимо макрозадач, описанных в этой части, существуют микрозадачи, упомянутые в главе Микрозадачи.

Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.

Также есть специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.

Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.
___

``` JavaScript
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.

Это важно, так как гарантирует, что общее окружение остаётся одним и тем же между микрозадачами – не изменены координаты мыши, не получены новые данные по сети и т.п.

Если мы хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений и до новых событий, то можем запланировать это через queueMicrotask.

Вот пример с индикатором выполнения, похожий на предыдущий, но в этот раз использована функция queueMicrotask вместо setTimeout. Обратите внимание – отрисовка страницы происходит только в самом конце. Как и в случае обычного синхронного кода.

___

``` JavaScript
<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // делаем часть крупной задачи (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e6) {
      queueMicrotask(count);
    }

  }

  count();
</script>
``` 

#  В общум Цикл событий это такой цикл который позволяет нам выводить асинхронный код   неки только сначала он выводит синхронный код потом промисы - микроэлементы а дальше  Set interval  и другие например:

``` JavaScript 
func log(value){
  console.log(value);
}

log("start")

 setTimeout(()=>{
  log("timeout")
 },3000)

 log("end")
```
___ 
Здесь сначала идет старт потом енд а потом таймаут логику я обьяснил выше
___

#  И еще микротаски создаёт промисы queueMicrotask mutationobserver 

#  А макротаски создает Таймеры  События и Браузерные нюансы
 #  Еще  Callstack  принимет в себя и обрабатывает 1 функцию потом когда она освободится принимает другую допустим

 ``` JavaScript
  log("1")

  setTimeout(()=>{
    log("2")
  },0)

  Promise.resolve().then(()=>{
    log("3")
  })

  log("4")
 ```

 # Здесь сначала идет 1 4 3 2 и Колстек принимает  по одной функции каждый раз и пока одна не будет завершена другая не начнется 

 #  Итог axios это библиотека для Чаваскрипта которая помогает сделать
 # код короче и понятнее а Цикл событий это цикл по которому идут функции